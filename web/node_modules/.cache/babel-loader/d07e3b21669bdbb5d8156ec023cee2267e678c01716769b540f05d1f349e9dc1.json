{"ast":null,"code":"import axios from \"axios\";\n\n// Base URL matches backend port and API prefix\nconst api = axios.create({\n  baseURL: \"http://localhost:8081/api\",\n  headers: {\n    \"Content-Type\": \"application/json\"\n  }\n});\n\n// Helpers to manage tokens\nexport const setTokens = ({\n  accessToken,\n  refreshToken\n}) => {\n  if (accessToken) localStorage.setItem(\"accessToken\", accessToken);\n  if (refreshToken) localStorage.setItem(\"refreshToken\", refreshToken);\n};\nexport const clearTokens = () => {\n  localStorage.removeItem(\"accessToken\");\n  localStorage.removeItem(\"refreshToken\");\n};\n\n// Attach access token to every request\napi.interceptors.request.use(config => {\n  const accessToken = localStorage.getItem(\"accessToken\");\n  if (accessToken) {\n    config.headers.Authorization = `Bearer ${accessToken}`;\n  }\n  return config;\n}, error => Promise.reject(error));\n\n// Refresh token flow on 401 responses\nlet isRefreshing = false;\nlet pendingRequests = [];\nconst processQueue = (error, token = null) => {\n  pendingRequests.forEach(({\n    resolve,\n    reject\n  }) => {\n    if (error) reject(error);else resolve(token);\n  });\n  pendingRequests = [];\n};\napi.interceptors.response.use(response => response, async error => {\n  const {\n    response,\n    config: originalRequest\n  } = error || {};\n  const status = response === null || response === void 0 ? void 0 : response.status;\n  if (status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    const refreshToken = localStorage.getItem(\"refreshToken\");\n    if (!refreshToken) {\n      clearTokens();\n      return Promise.reject(error);\n    }\n    if (isRefreshing) {\n      return new Promise((resolve, reject) => {\n        pendingRequests.push({\n          resolve,\n          reject\n        });\n      }).then(newAccessToken => {\n        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;\n        return api(originalRequest);\n      }).catch(err => Promise.reject(err));\n    }\n    isRefreshing = true;\n    try {\n      const {\n        data\n      } = await api.post(\"/auth/refresh\", {\n        refreshToken\n      });\n      const newAccessToken = data === null || data === void 0 ? void 0 : data.accessToken;\n      if (!newAccessToken) throw new Error(\"No accessToken in refresh response\");\n      setTokens({\n        accessToken: newAccessToken\n      });\n      api.defaults.headers.Authorization = `Bearer ${newAccessToken}`;\n      processQueue(null, newAccessToken);\n      originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;\n      return api(originalRequest);\n    } catch (refreshErr) {\n      clearTokens();\n      processQueue(refreshErr, null);\n      return Promise.reject(refreshErr);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  console.error(\"API Error:\", error);\n  return Promise.reject(error);\n});\nexport default api;","map":{"version":3,"names":["axios","api","create","baseURL","headers","setTokens","accessToken","refreshToken","localStorage","setItem","clearTokens","removeItem","interceptors","request","use","config","getItem","Authorization","error","Promise","reject","isRefreshing","pendingRequests","processQueue","token","forEach","resolve","response","originalRequest","status","_retry","push","then","newAccessToken","catch","err","data","post","Error","defaults","refreshErr","console"],"sources":["C:/Users/PC/Downloads/IT342/IT342_G5_Hopista_Lab1/web/src/config/axios.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// Base URL matches backend port and API prefix\r\nconst api = axios.create({\r\n    baseURL: \"http://localhost:8081/api\",\r\n    headers: { \"Content-Type\": \"application/json\" },\r\n});\r\n\r\n// Helpers to manage tokens\r\nexport const setTokens = ({ accessToken, refreshToken }) => {\r\n    if (accessToken) localStorage.setItem(\"accessToken\", accessToken);\r\n    if (refreshToken) localStorage.setItem(\"refreshToken\", refreshToken);\r\n};\r\n\r\nexport const clearTokens = () => {\r\n    localStorage.removeItem(\"accessToken\");\r\n    localStorage.removeItem(\"refreshToken\");\r\n};\r\n\r\n// Attach access token to every request\r\napi.interceptors.request.use(\r\n    (config) => {\r\n        const accessToken = localStorage.getItem(\"accessToken\");\r\n        if (accessToken) {\r\n            config.headers.Authorization = `Bearer ${accessToken}`;\r\n        }\r\n        return config;\r\n    },\r\n    (error) => Promise.reject(error)\r\n);\r\n\r\n// Refresh token flow on 401 responses\r\nlet isRefreshing = false;\r\nlet pendingRequests = [];\r\n\r\nconst processQueue = (error, token = null) => {\r\n    pendingRequests.forEach(({ resolve, reject }) => {\r\n        if (error) reject(error);\r\n        else resolve(token);\r\n    });\r\n    pendingRequests = [];\r\n};\r\n\r\napi.interceptors.response.use(\r\n    (response) => response,\r\n    async (error) => {\r\n        const { response, config: originalRequest } = error || {};\r\n        const status = response?.status;\r\n\r\n        if (status === 401 && !originalRequest._retry) {\r\n            originalRequest._retry = true;\r\n            const refreshToken = localStorage.getItem(\"refreshToken\");\r\n            if (!refreshToken) {\r\n                clearTokens();\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            if (isRefreshing) {\r\n                return new Promise((resolve, reject) => {\r\n                    pendingRequests.push({ resolve, reject });\r\n                })\r\n                    .then((newAccessToken) => {\r\n                        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;\r\n                        return api(originalRequest);\r\n                    })\r\n                    .catch((err) => Promise.reject(err));\r\n            }\r\n\r\n            isRefreshing = true;\r\n            try {\r\n                const { data } = await api.post(\"/auth/refresh\", { refreshToken });\r\n                const newAccessToken = data?.accessToken;\r\n                if (!newAccessToken) throw new Error(\"No accessToken in refresh response\");\r\n\r\n                setTokens({ accessToken: newAccessToken });\r\n                api.defaults.headers.Authorization = `Bearer ${newAccessToken}`;\r\n                processQueue(null, newAccessToken);\r\n\r\n                originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;\r\n                return api(originalRequest);\r\n            } catch (refreshErr) {\r\n                clearTokens();\r\n                processQueue(refreshErr, null);\r\n                return Promise.reject(refreshErr);\r\n            } finally {\r\n                isRefreshing = false;\r\n            }\r\n        }\r\n\r\n        console.error(\"API Error:\", error);\r\n        return Promise.reject(error);\r\n    }\r\n);\r\n\r\nexport default api;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}